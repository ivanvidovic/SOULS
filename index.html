<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-F-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Voice Reactive Digital Soul</title>
    <!-- Tailwind CSS CDN for basic styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- p5.js library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.2/p5.min.js"></script>
    <!-- p5.sound.js library for audio input -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.2/addons/p5.sound.min.js"></script>
    <style>
        body {
            margin: 0;
            overflow: hidden; /* Hide scrollbars */
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background-color: #000000; /* Solid Black Background */
            font-family: "Inter", sans-serif;
            color: #e0e0e0;
        }
        canvas {
            display: block;
            max-width: 100vw; /* Ensure canvas fits screen width */
            max-height: 100vh; /* Ensure canvas fits screen height */
        }
        #controls {
            position: absolute;
            top: 1rem;
            left: 50%;
            transform: translateX(-50%);
            z-index: 10;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        button {
            background-color: #0f3460;
            color: #ffffff; /* Icon color is now white */
            width: 2.25rem; /* Decreased size by 25% */
            height: 2.25rem; /* Decreased size by 25% */
            border-radius: 50%; /* Makes the button a perfect circle */
            border: 2px solid #ffffff; /* Border is now white */
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.2);
            display: flex;
            align-items: center;
            justify-content: center;
        }
        button:hover {
            background-color: #e94560; /* Hover fill is red */
            border-color: #e94560; /* Hover border is red */
            color: #ffffff; /* Hover icon is white */
            box-shadow: 0 6px 8px rgba(0, 0, 0, 0.3);
            /* Removed transform so it doesn't move */
        }
        button:disabled {
            background-color: #3a3a5a;
            color: #999;
            border-color: #555;
            cursor: not-allowed;
            box-shadow: none;
            transform: none;
        }
        #message-box {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.7);
            z-index: 1000;
            display: none; /* Hidden by default */
            text-align: center;
            max-width: 80%;
        }
        #message-box button {
            margin-top: 15px;
            background-color: #e94560;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
        }
        #message-box button:hover {
            background-color: #c0392b;
        }
    </style>
</head>
<body>
    <div id="controls">
        <button id="startButton" aria-label="Activate Mic">
            <!-- SVG Microphone Icon -->
            <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z"></path>
                <path d="M19 10v2a7 7 0 0 1-14 0v-2"></path>
                <line x1="12" y1="19" x2="12" y2="23"></line>
                <line x1="8" y1="23" x2="16" y2="23"></line>
            </svg>
        </button>
    </div>

    <div id="message-box">
        <p id="message-content"></p>
        <button onclick="hideMessageBox()">OK</button>
    </div>

    <script>
        let mic;
        let fft;
        let particles = []; // For the orbiting spheres with lines
        let star; 
        const numParticles = 200;
        let centralSphereSize = 150; // Base size for scaling
        let currentVolume = 0;
        let bassEnergy = 0;
        let audioStarted = false; // Flag to track if audio (mic) has started
        let startButton;

        // Global scene rotation variables for X, Y, Z axes
        let sceneRotationX = 0;
        let sceneRotationY = 0;
        let sceneRotationZ = 0;
        let sceneNoiseOffsetX = 10000;
        let sceneNoiseOffsetY = 0;
        let sceneNoiseOffsetZ = 20000;

        // Variables for interactive orbiting controls
        let targetSceneRotationX = 0;
        let targetSceneRotationY = 0;
        const rotationLerpFactor = 0.08;
        let isDragging = false;
        let prevMouseX = 0;
        let prevMouseY = 0;

        // Variables for smooth camera zoom control
        let cameraZ;
        let targetCameraZ; // The zoom level we want to be at
        let minZoom;
        let maxZoom;
        const zoomLerpFactor = 0.1; // Easing factor for smooth zoom

        // Audio history for delayed response
        let audioHistory = [];
        const historyLength = 8;
        const minActivationVolume = 0.15;
        const minActivationBass = 120;

        // Fixed detail for the chunky central sphere
        const centralSphereDetailX = 24;
        const centralSphereDetailY = 16;

        // Define the custom hex colors for the small spheres
        const sphereColors = [
            [197, 62, 192], // #C53EC0 (Purple)
            [66, 255, 255],  // #42FFFF (Cyan)
            [182, 147, 154], // #B6939A (Rose Gray)
            [47, 28, 114],   // #2F1C72 (Dark Indigo)
            [255, 89, 126]   // #FF597E (Pink Red)
        ];

        // p5.Graphics buffer for off-screen rendering
        let mainSceneBuffer;

        const TAPER_START_RADIUS = 160;
        const TAPER_END_RADIUS = 300;

        function showMessageBox(message) {
            document.getElementById('message-content').innerText = message;
            document.getElementById('message-box').style.display = 'block';
        }

        function hideMessageBox() {
            document.getElementById('message-box').style.display = 'none';
        }
        
        class Star {
            constructor() {
                this.baseCoreSize = 2;
                this.coreSize = this.baseCoreSize;
                this.targetCoreSize = this.baseCoreSize;
                
                this.rotation = createVector(random(TWO_PI), random(TWO_PI), random(TWO_PI));
                this.rotationSpeed = createVector(random(-0.005, 0.005), random(-0.005, 0.005), random(-0.005, 0.005));
            }

            applyAudioInfluence(volume, bass) {
                let effectiveVolume = (volume > minActivationVolume) ? volume : 0;
                let effectiveBass = (bass > minActivationBass) ? bass : 0;
                let volumeInfluenceAmount = map(effectiveVolume, minActivationVolume, 0.6, 0, 1, true);
                let bassInfluenceAmount = map(effectiveBass, minActivationBass, 200, 0, 1, true);
                let totalAudioInfluence = max(volumeInfluenceAmount, bassInfluenceAmount);

                this.targetCoreSize = this.baseCoreSize + (this.baseCoreSize * 10 * totalAudioInfluence);
            }

            update() {
                this.coreSize = lerp(this.coreSize, this.targetCoreSize, 0.1);
                this.rotation.add(this.rotationSpeed);
            }

            display(graphicsBuffer) {
                graphicsBuffer.push();
                graphicsBuffer.rotateX(this.rotation.x);
                graphicsBuffer.rotateY(this.rotation.y);
                graphicsBuffer.rotateZ(this.rotation.z);
                
                graphicsBuffer.noStroke();
                graphicsBuffer.fill(255, 255, 255, 255); 
                graphicsBuffer.sphere(this.coreSize);
                
                graphicsBuffer.pop();
            }
        }

        class ParticleSphere {
            constructor() {
                this.minOrbitRadius = 160;
                this.maxOrbitRadius = random(170, 300);

                let initialRadius = map(pow(random(1), 2), 0, 1, this.minOrbitRadius, this.maxOrbitRadius);
                this.pos = p5.Vector.random3D().mult(initialRadius);

                this.vel = p5.Vector.random3D().mult(random(0.05, 0.2));
                this.acc = createVector(0, 0, 0);
                this.baseSize = random(1, 4);
                this.size = this.baseSize * 0.5;
                this.targetSize = this.baseSize * 0.5;
                this.originalRGB = sphereColors[floor(random(sphereColors.length))];
                this.currentBrightnessFactor = 0.5;
                this.noiseOffset = random(1000);
                this.maxSpeed = random(0.8, 1.5);
                this.maxForce = random(0.04, 0.08);
                
                this.flowingElements = [];
                this.flowSpawnRate = floor(random(30, 90));
                this.maxFlowElements = floor(random(3, 8));
                this.flowElementBaseSize = random(0.5, 1.5);
                this.flowDirection = 0;
                let randFlow = random();
                if (randFlow < 0.45) {
                    this.flowDirection = 1;
                } else if (randFlow < 0.90) {
                    this.flowDirection = -1;
                }
            }

            applyForce(force) {
                this.acc.add(force);
            }

            update() {
                let noiseFactor = 0.001;
                let nx = map(noise(this.noiseOffset, frameCount * noiseFactor, 0), 0, 1, -this.maxForce, this.maxForce);
                let ny = map(noise(this.noiseOffset + 1000, frameCount * noiseFactor, 0), 0, 1, -this.maxForce, this.maxForce);
                let nz = map(noise(this.noiseOffset + 2000, frameCount * noiseFactor, 0), 0, 1, -this.maxForce, this.maxForce);
                this.applyForce(createVector(nx, ny, nz));

                let currentDistance = this.pos.mag();
                if (currentDistance > this.maxOrbitRadius) {
                    let steer = p5.Vector.sub(createVector(0,0,0), this.pos);
                    steer.setMag(map(currentDistance, this.maxOrbitRadius, this.maxOrbitRadius + 50, 0, this.maxForce * 0.7));
                    this.applyForce(steer);
                } else if (currentDistance < this.minOrbitRadius) {
                    let steer = p5.Vector.sub(this.pos, createVector(0,0,0));
                    steer.setMag(map(currentDistance, this.minOrbitRadius, this.minOrbitRadius - 50, 0, this.maxForce * 0.7));
                    this.applyForce(steer);
                }

                let tangentialForce = createVector(-this.pos.y, this.pos.x, this.pos.z * 0.1).normalize();
                tangentialForce.mult(this.maxForce * 0.2);
                this.applyForce(tangentialForce);

                this.vel.add(this.acc);
                this.vel.limit(this.maxSpeed);
                this.pos.add(this.vel);
                this.acc.mult(0);
                this.vel.mult(0.95);

                if (this.flowDirection !== 0) {
                    if (frameCount % this.flowSpawnRate === 0 && this.flowingElements.length < this.maxFlowElements) {
                        this.flowingElements.push({
                            offset: this.flowDirection === 1 ? 0 : 1,
                            // MODIFICATION: Speed reduced by a factor of 3
                            speed: random(0.000416, 0.00125),
                            size: random(0.625, 1.875) * this.flowElementBaseSize
                        });
                    }
                    for (let i = this.flowingElements.length - 1; i >= 0; i--) {
                        let flowEl = this.flowingElements[i];
                        flowEl.offset += flowEl.speed * this.flowDirection;
                        if ((this.flowDirection === 1 && flowEl.offset > 1.1) || (this.flowDirection === -1 && flowEl.offset < -0.1)) {
                            this.flowingElements.splice(i, 1);
                        }
                    }
                }
            }

            applyAudioInfluence(history) {
                let currentDistance = this.pos.mag();
                
                let distanceInfluenceFactor = map(currentDistance, TAPER_START_RADIUS, TAPER_END_RADIUS, 1.0, 0.1, true);
                
                let delayFrames = floor(constrain(map(currentDistance, this.minOrbitRadius, this.maxOrbitRadius, 0, historyLength - 1), 0, historyLength - 1));
                let delayedAudio = history[(historyLength - 1) - delayFrames] || { volume: 0, bass: 0 };

                let effectiveAmplitude = (delayedAudio.volume > minActivationVolume) ? delayedAudio.volume : 0;
                let effectiveBass = (delayedAudio.bass > minActivationBass) ? delayedAudio.bass : 0;

                let volumeInfluenceAmount = map(effectiveAmplitude, minActivationVolume, 0.6, 0, 1, true);
                let bassInfluenceAmount = map(effectiveBass, minActivationBass, 200, 0, 1, true);
                let totalAudioInfluence = max(volumeInfluenceAmount, bassInfluenceAmount) * distanceInfluenceFactor;

                this.targetSize = (this.baseSize * 0.5) + (this.baseSize * 9.0 * totalAudioInfluence);
                let targetBrightness = (totalAudioInfluence > 0) ? 1.0 : 0.5;

                let lerpFactorBrightness = 0.1;
                if (targetBrightness < this.currentBrightnessFactor) {
                    lerpFactorBrightness = 0.3;
                }
                this.currentBrightnessFactor = lerp(this.currentBrightnessFactor, targetBrightness, lerpFactorBrightness);

                let lerpFactorSize;
                if (this.targetSize > this.size) {
                    lerpFactorSize = 0.1;
                } else {
                    lerpFactorSize = 0.3;
                }
                this.size = lerp(this.size, this.targetSize, lerpFactorSize);
            }

            display(graphicsBuffer, zoomMultiplier, zoomGradientFactor, zoomStrokeMultiplier) {
                // Draw the connector line
                graphicsBuffer.push();
                // Apply zoom-based thinning
                graphicsBuffer.strokeWeight(map(this.currentBrightnessFactor, 0.5, 1.0, 0.5, 2.5) * zoomStrokeMultiplier);

                const whiteColor = color(255);
                const particleColor = color(this.originalRGB[0], this.originalRGB[1], this.originalRGB[2]);
                const finalColor = lerpColor(particleColor, whiteColor, zoomGradientFactor);
                const finalAlpha = this.currentBrightnessFactor * 100;

                graphicsBuffer.stroke(red(finalColor), green(finalColor), blue(finalColor), finalAlpha);
                graphicsBuffer.line(0, 0, 0, this.pos.x, this.pos.y, this.pos.z);
                graphicsBuffer.pop();

                // Draw flowing elements
                if (this.flowDirection !== 0) {
                    graphicsBuffer.push();
                    graphicsBuffer.blendMode(ADD);
                    let centerPoint = createVector(0, 0, 0);
                    for (let flowEl of this.flowingElements) {
                        let pFlow = (this.flowDirection === 1) ?
                            p5.Vector.lerp(centerPoint, this.pos, flowEl.offset) :
                            p5.Vector.lerp(this.pos, centerPoint, 1 - flowEl.offset);

                        let flowProgressAlpha = (this.flowDirection === -1) ? 1 - flowEl.offset : flowEl.offset;
                        let flowAlpha = 255;
                        if (flowProgressAlpha < 0.1) flowAlpha = map(flowProgressAlpha, 0, 0.1, 100, 255);
                        else if (flowProgressAlpha > 0.9) flowAlpha = map(flowProgressAlpha, 0.9, 1, 255, 100);

                        flowAlpha = constrain(this.currentBrightnessFactor * flowAlpha, 0, 255);
                        
                        let sizeMultiplier = map(this.currentBrightnessFactor, 0.5, 1.0, 0.5, 1.0, true);
                        let displaySize = flowEl.size * sizeMultiplier * zoomMultiplier;

                        graphicsBuffer.noStroke();
                        graphicsBuffer.fill(this.originalRGB[0], this.originalRGB[1], this.originalRGB[2], flowAlpha);
                        graphicsBuffer.push();
                        graphicsBuffer.translate(pFlow.x, pFlow.y, pFlow.z);
                        graphicsBuffer.sphere(displaySize);
                        graphicsBuffer.pop();
                    }
                    graphicsBuffer.pop();
                }

                // Draw the main solid sphere
                graphicsBuffer.push();
                graphicsBuffer.translate(this.pos.x, this.pos.y, this.pos.z);
                graphicsBuffer.noStroke();
                graphicsBuffer.fill(this.originalRGB[0] * this.currentBrightnessFactor,
                                     this.originalRGB[1] * this.currentBrightnessFactor,
                                     this.originalRGB[2] * this.currentBrightnessFactor, 255);
                graphicsBuffer.sphere(this.size);
                graphicsBuffer.pop();
            }
        }
        
        function setup() {
            createCanvas(windowWidth, windowHeight, WEBGL);
            pixelDensity(1);

            mainSceneBuffer = createGraphics(width, height, WEBGL);
            mainSceneBuffer.pixelDensity(1);

            // Initialize camera zoom settings
            maxZoom = (height / 2) / tan(PI / 6); // Default camera position
            minZoom = centralSphereSize + 50; // Closest zoom distance
            cameraZ = maxZoom; // Start at the farthest zoom
            targetCameraZ = cameraZ; // Initialize target zoom

            for (let i = 0; i < numParticles; i++) {
                particles.push(new ParticleSphere());
            }
            
            star = new Star();

            startButton = document.getElementById('startButton');
            startButton.addEventListener('click', startAudio);

            targetSceneRotationX = sceneRotationX;
            targetSceneRotationY = sceneRotationY;
        }

        function mouseWheel(event) {
            targetCameraZ += event.delta * 0.75;
            targetCameraZ = constrain(targetCameraZ, minZoom, maxZoom);
            return false;
        }

        function mousePressed() {
            isDragging = true;
            prevMouseX = mouseX;
            prevMouseY = mouseY;
        }

        function mouseReleased() {
            isDragging = false;
        }

        function mouseDragged() {
            if (isDragging) {
                let dx = mouseX - prevMouseX;
                let dy = mouseY - prevMouseY;
                targetSceneRotationY += dx * 0.005;
                targetSceneRotationX -= dy * 0.005;
                prevMouseX = mouseX;
                prevMouseY = mouseY;
            }
        }

        function touchStarted(event) {
            if (event.target.tagName === 'CANVAS') {
                if (touches.length > 0) {
                    isDragging = true;
                    prevMouseX = touches[0].x;
                    prevMouseY = touches[0].y;
                }
                return false;
            }
        }

        function touchEnded(event) {
            isDragging = false;
            if (event.target.tagName === 'CANVAS') {
                return false;
            }
        }

        function touchMoved(event) {
            if (isDragging && touches.length > 0) {
                let dx = touches[0].x - prevMouseX;
                let dy = touches[0].y - prevMouseY;
                targetSceneRotationY += dx * 0.005;
                targetSceneRotationX -= dy * 0.005;
                prevMouseX = touches[0].x;
                prevMouseY = touches[0].y;
            }
            if (event.target.tagName === 'CANVAS') {
                return false;
            }
        }

        function startAudio() {
            if (audioStarted) return;
            if (getAudioContext().state === 'suspended') {
                getAudioContext().resume();
            }
            mic = new p5.AudioIn();
            fft = new p5.FFT(0.8, 128);
            fft.setInput(mic);
            mic.start(() => {
                audioStarted = true;
                startButton.disabled = true;
            }, (err) => {
                console.error("Microphone access error:", err);
                showMessageBox("Microphone access denied or not available. Please allow microphone access to enable voice reactivity.");
                audioStarted = true; 
                startButton.disabled = true;
            });
        }

        function windowResized() {
            resizeCanvas(windowWidth, windowHeight);
            mainSceneBuffer = createGraphics(width, height, WEBGL);
            mainSceneBuffer.pixelDensity(1);
            maxZoom = (height / 2) / tan(PI / 6);
            cameraZ = constrain(cameraZ, minZoom, maxZoom);
            targetCameraZ = constrain(targetCameraZ, minZoom, maxZoom);
        }

        function draw() {
            mainSceneBuffer.background(0, 0);
            mainSceneBuffer.push();

            cameraZ = lerp(cameraZ, targetCameraZ, zoomLerpFactor);
            mainSceneBuffer.camera(0, 0, cameraZ, 0, 0, 0, 0, 1, 0);

            sceneRotationX = lerp(sceneRotationX, targetSceneRotationX, rotationLerpFactor);
            sceneRotationY = lerp(sceneRotationY, targetSceneRotationY, rotationLerpFactor);
            mainSceneBuffer.rotateX(sceneRotationX);
            mainSceneBuffer.rotateY(sceneRotationY);
            let rotationSpeedFactor = 0.005;
            let noiseIncrement = 0.005;
            sceneRotationZ += map(noise(sceneNoiseOffsetZ), 0, 1, -rotationSpeedFactor, rotationSpeedFactor);
            sceneNoiseOffsetZ += noiseIncrement;
            mainSceneBuffer.rotateZ(sceneRotationZ);

            let blackSphereAlpha = map(cameraZ, minZoom, maxZoom, 0, 255, true);
            let zoomSizeMultiplier = map(cameraZ, maxZoom, minZoom, 1.0, 0.5, true);
            
            // MODIFICATION: The gradient now starts fading in at 66% of the zoom distance.
            const gradientStartZoom = lerp(maxZoom, minZoom, 0.66);
            let zoomGradientFactor = map(cameraZ, gradientStartZoom, minZoom, 0, 1, true);
            
            // MODIFICATION: New multiplier to make lines thinner when zoomed in.
            let zoomStrokeMultiplier = map(cameraZ, maxZoom, minZoom, 1.0, 0.5, true);
            
            if (audioStarted) {
                if (mic && mic.enabled && getAudioContext().state === 'running') {
                    currentVolume = mic.getLevel();
                    fft.analyze();
                    bassEnergy = fft.getEnergy('bass');
                } else {
                    currentVolume = 0.0;
                    bassEnergy = 0;
                }
                audioHistory.push({ volume: currentVolume, bass: bassEnergy });
                if (audioHistory.length > historyLength) {
                    audioHistory.shift();
                }

                let effectiveVolumeCentral = (currentVolume > minActivationVolume) ? currentVolume : 0;
                let effectiveBassEnergyCentral = (bassEnergy > minActivationBass) ? bassEnergy : 0;
                let targetCentralSphereSize = 150;
                targetCentralSphereSize += map(effectiveVolumeCentral, minActivationVolume, 0.6, 0, 112.5, true);
                targetCentralSphereSize += map(effectiveBassEnergyCentral, minActivationBass, 200, 0, 45, true);

                star.update();
                star.applyAudioInfluence(currentVolume, bassEnergy);
                star.display(mainSceneBuffer);

                for (let particle of particles) {
                    particle.update();
                    particle.applyAudioInfluence(audioHistory);
                    particle.display(mainSceneBuffer, zoomSizeMultiplier, zoomGradientFactor, zoomStrokeMultiplier);
                }

                mainSceneBuffer.push();
                mainSceneBuffer.noStroke();
                mainSceneBuffer.fill(0, blackSphereAlpha);
                mainSceneBuffer.sphere(targetCentralSphereSize, centralSphereDetailX, centralSphereDetailY);
                mainSceneBuffer.pop();
            } else {
                while (audioHistory.length < historyLength) {
                    audioHistory.push({ volume: 0.0, bass: 0 });
                }
                while (audioHistory.length > historyLength) {
                    audioHistory.shift();
                }
                
                star.update();
                star.applyAudioInfluence(0,0);
                star.display(mainSceneBuffer);

                for (let particle of particles) {
                    particle.update();
                    particle.applyAudioInfluence(audioHistory);
                    particle.display(mainSceneBuffer, zoomSizeMultiplier, zoomGradientFactor, zoomStrokeMultiplier);
                }
                mainSceneBuffer.push();
                mainSceneBuffer.noStroke();
                mainSceneBuffer.fill(0, blackSphereAlpha);
                mainSceneBuffer.sphere(centralSphereSize, centralSphereDetailX, centralSphereDetailY);
                mainSceneBuffer.pop();
            }
            mainSceneBuffer.pop();

            background(0);
            image(mainSceneBuffer, -width / 2, -height / 2);
        }
    </script>
</body>
</html>
