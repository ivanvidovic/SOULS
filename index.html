<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-F-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Voice Reactive Digital Soul</title>
    <!-- Tailwind CSS CDN for basic styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- p5.js library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.2/p5.min.js"></script>
    <!-- p5.sound.js library for audio input -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.2/addons/p5.sound.min.js"></script>
    <style>
        body {
            margin: 0;
            overflow: hidden; /* Hide scrollbars */
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background-color: #000000; /* Solid Black Background */
            font-family: "Inter", sans-serif;
            color: #e0e0e0;
        }
        canvas {
            display: block;
            max-width: 100vw; /* Ensure canvas fits screen width */
            max-height: 100vh; /* Ensure canvas fits screen height */
        }
        #controls {
            position: absolute;
            top: 1rem;
            left: 50%;
            transform: translateX(-50%);
            z-index: 10;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        button {
            background-color: #0f3460;
            color: #ffffff; /* Icon color is now white */
            width: 2.25rem; /* Decreased size by 25% */
            height: 2.25rem; /* Decreased size by 25% */
            border-radius: 50%; /* Makes the button a perfect circle */
            border: 2px solid #ffffff; /* Border is now white */
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.2);
            display: flex;
            align-items: center;
            justify-content: center;
        }
        button:hover {
            background-color: #e94560; /* Hover fill is red */
            border-color: #e94560; /* Hover border is red */
            color: #ffffff; /* Hover icon is white */
            box-shadow: 0 6px 8px rgba(0, 0, 0, 0.3);
            /* Removed transform so it doesn't move */
        }
        button:disabled {
            background-color: #3a3a5a;
            color: #999;
            border-color: #555;
            cursor: not-allowed;
            box-shadow: none;
            transform: none;
        }
        #message-box {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.7);
            z-index: 1000;
            display: none; /* Hidden by default */
            text-align: center;
            max-width: 80%;
        }
        #message-box button {
            margin-top: 15px;
            background-color: #e94560;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
        }
        #message-box button:hover {
            background-color: #c0392b;
        }
    </style>
</head>
<body>
    <div id="controls">
        <button id="startButton" aria-label="Activate Mic">
            <!-- SVG Microphone Icon -->
            <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z"></path>
                <path d="M19 10v2a7 7 0 0 1-14 0v-2"></path>
                <line x1="12" y1="19" x2="12" y2="23"></line>
                <line x1="8" y1="23" x2="16" y2="23"></line>
            </svg>
        </button>
    </div>

    <div id="message-box">
        <p id="message-content"></p>
        <button onclick="hideMessageBox()">OK</button>
    </div>

    <script>
        let mic;
        let fft;
        let particles = []; // For the orbiting spheres with lines
        let star; 
        const numParticles = 200;
        let centralSphereSize = 150; // Base size for scaling
        let currentCentralSphereSize; // For transition animation
        let currentVolume = 0;
        let bassEnergy = 0;
        let audioStarted = false; 
        let startButton;

        // State variables for the awakening transition
        let awakeningState = 'dormant'; // 'dormant', 'awakening', 'active'
        let transitionProgress = 0;
        const sphereTransitionDuration = 45; 
        // MODIFICATION: Changed black sphere transition duration from 90 to 60
        const blackSphereTransitionDuration = 60; 

        // Global scene rotation variables for X, Y, Z axes
        let sceneRotationX = 0;
        let sceneRotationY = 0;
        let sceneRotationZ = 0;
        let sceneNoiseOffsetX = 10000;
        let sceneNoiseOffsetY = 0;
        let sceneNoiseOffsetZ = 20000;

        // Variables for interactive orbiting controls
        let targetSceneRotationX = 0;
        let targetSceneRotationY = 0;
        const rotationLerpFactor = 0.08;
        let isDragging = false;
        let prevMouseX = 0;
        let prevMouseY = 0;

        // Variables for smooth camera zoom control
        let cameraZ;
        let targetCameraZ; // The zoom level we want to be at
        let minZoom;
        let maxZoom;
        const zoomLerpFactor = 0.1; // Easing factor for smooth zoom

        // Audio history for delayed response
        let audioHistory = [];
        const historyLength = 8;
        const minActivationVolume = 0.15;
        const minActivationBass = 120;

        // Fixed detail for the chunky central sphere
        const centralSphereDetailX = 24;
        const centralSphereDetailY = 16;

        // Define the custom hex colors for the small spheres
        const sphereColors = [
            [197, 62, 192], // #C53EC0 (Purple)
            [66, 255, 255],  // #42FFFF (Cyan)
            [182, 147, 154], // #B6939A (Rose Gray)
            [47, 28, 114],   // #2F1C72 (Dark Indigo)
            [255, 89, 126]   // #FF597E (Pink Red)
        ];

        // p5.Graphics buffer for off-screen rendering
        let mainSceneBuffer;

        const TAPER_START_RADIUS = 160;
        const TAPER_END_RADIUS = 300;

        function showMessageBox(message) {
            document.getElementById('message-content').innerText = message;
            document.getElementById('message-box').style.display = 'block';
        }

        function hideMessageBox() {
            document.getElementById('message-box').style.display = 'none';
        }
        
        class Star {
            constructor() {
                this.baseCoreSize = 2;
                this.coreSize = this.baseCoreSize;
                this.targetCoreSize = this.baseCoreSize;
                
                this.rotation = createVector(random(TWO_PI), random(TWO_PI), random(TWO_PI));
                this.rotationSpeed = createVector(random(-0.005, 0.005), random(-0.005, 0.005), random(-0.005, 0.005));
            }

            applyAudioInfluence(volume, bass) {
                let effectiveVolume = (volume > minActivationVolume) ? volume : 0;
                let effectiveBass = (bass > minActivationBass) ? bass : 0;
                let volumeInfluenceAmount = map(effectiveVolume, minActivationVolume, 0.6, 0, 1, true);
                let bassInfluenceAmount = map(effectiveBass, minActivationBass, 200, 0, 1, true);
                let totalAudioInfluence = max(volumeInfluenceAmount, bassInfluenceAmount);

                this.targetCoreSize = this.baseCoreSize + (this.baseCoreSize * 10 * totalAudioInfluence);
            }

            update() {
                this.coreSize = lerp(this.coreSize, this.targetCoreSize, 0.1);
                this.rotation.add(this.rotationSpeed);
            }

            display(graphicsBuffer) {
                graphicsBuffer.push();
                graphicsBuffer.rotateX(this.rotation.x);
                graphicsBuffer.rotateY(this.rotation.y);
                graphicsBuffer.rotateZ(this.rotation.z);
                
                graphicsBuffer.noStroke();
                graphicsBuffer.fill(255, 255, 255, 255); 
                graphicsBuffer.sphere(this.coreSize);
                
                graphicsBuffer.pop();
            }
        }

        class ParticleSphere {
            constructor(initialPos, targetPos) {
                this.initialPos = initialPos;
                this.targetPos = targetPos;
                this.pos = initialPos.copy();

                this.vel = createVector();
                this.acc = createVector(0, 0, 0);
                this.baseSize = random(1, 4);
                this.size = this.baseSize * 0.5;
                this.targetSize = this.baseSize * 0.5;
                this.originalRGB = sphereColors[floor(random(sphereColors.length))];
                this.currentBrightnessFactor = 0.5;
                this.noiseOffset = random(1000);
                this.maxSpeed = random(0.8, 1.5);
                this.maxForce = random(0.04, 0.08);
                
                this.flowingElements = [];
                this.flowSpawnRate = floor(random(30, 90));
                this.maxFlowElements = floor(random(3, 8));
                this.flowElementBaseSize = random(0.5, 1.5);
                this.flowDirection = 0;
                let randFlow = random();
                if (randFlow < 0.45) {
                    this.flowDirection = 1;
                } else if (randFlow < 0.90) {
                    this.flowDirection = -1;
                }
                
                if (random() < 0.33) {
                    this.maxOpacity = 255; 
                } else {
                    this.maxOpacity = random(150, 220);
                }
            }

            applyForce(force) {
                this.acc.add(force);
            }

            update() {
                if (awakeningState === 'dormant') {
                    return; 
                } 
                
                if (awakeningState === 'awakening') {
                    const lerpAmount = easeInOutCubic(transitionProgress / sphereTransitionDuration);
                    this.pos = p5.Vector.lerp(this.initialPos, this.targetPos, lerpAmount);
                } else { // 'active' state
                    let organicForceFactor = 1.0;
                    let noiseFactor = 0.001;
                    let nx = map(noise(this.noiseOffset, frameCount * noiseFactor, 0), 0, 1, -this.maxForce, this.maxForce);
                    let ny = map(noise(this.noiseOffset + 1000, frameCount * noiseFactor, 0), 0, 1, -this.maxForce, this.maxForce);
                    let nz = map(noise(this.noiseOffset + 2000, frameCount * noiseFactor, 0), 0, 1, -this.maxForce, this.maxForce);
                    this.applyForce(createVector(nx, ny, nz).mult(organicForceFactor));

                    let currentDistance = this.pos.mag();
                    if (currentDistance > this.targetPos.mag()) { 
                        let steer = p5.Vector.sub(createVector(0,0,0), this.pos);
                        steer.setMag(map(currentDistance, this.targetPos.mag(), this.targetPos.mag() + 50, 0, this.maxForce * 0.7));
                        this.applyForce(steer.mult(organicForceFactor));
                    } else if (currentDistance < 150) { 
                        let steer = p5.Vector.sub(this.pos, createVector(0,0,0));
                        steer.setMag(map(currentDistance, 150, 100, 0, this.maxForce * 1.5));
                        this.applyForce(steer);
                    }

                    let tangentialForce = createVector(-this.pos.y, this.pos.x, this.pos.z * 0.1).normalize();
                    tangentialForce.mult(this.maxForce * 0.2);
                    this.applyForce(tangentialForce.mult(organicForceFactor));

                    this.vel.add(this.acc);
                    this.vel.limit(this.maxSpeed);
                    this.pos.add(this.vel);
                    this.acc.mult(0);
                    this.vel.mult(0.95);
                }

                if (awakeningState === 'active' && this.flowDirection !== 0) {
                    if (frameCount % this.flowSpawnRate === 0 && this.flowingElements.length < this.maxFlowElements) {
                        this.flowingElements.push({
                            offset: this.flowDirection === 1 ? 0 : 1,
                            speed: random(0.000416, 0.00125),
                            size: random(0.625, 1.875) * this.flowElementBaseSize
                        });
                    }
                    for (let i = this.flowingElements.length - 1; i >= 0; i--) {
                        let flowEl = this.flowingElements[i];
                        flowEl.offset += flowEl.speed * this.flowDirection;
                        if ((this.flowDirection === 1 && flowEl.offset > 1.1) || (this.flowDirection === -1 && flowEl.offset < -0.1)) {
                            this.flowingElements.splice(i, 1);
                        }
                    }
                }
            }

            applyAudioInfluence(history) {
                if (awakeningState !== 'active') return;

                let currentDistance = this.pos.mag();
                
                let distanceInfluenceFactor = map(currentDistance, TAPER_START_RADIUS, TAPER_END_RADIUS, 1.0, 0.1, true);
                
                let delayFrames = floor(constrain(map(currentDistance, 160, 300, 0, historyLength - 1), 0, historyLength - 1));
                let delayedAudio = history[(historyLength - 1) - delayFrames] || { volume: 0, bass: 0 };

                let effectiveAmplitude = (delayedAudio.volume > minActivationVolume) ? delayedAudio.volume : 0;
                let effectiveBass = (delayedAudio.bass > minActivationBass) ? delayedAudio.bass : 0;

                let volumeInfluenceAmount = map(effectiveAmplitude, minActivationVolume, 0.6, 0, 1, true);
                let bassInfluenceAmount = map(effectiveBass, minActivationBass, 200, 0, 1, true);
                let totalAudioInfluence = max(volumeInfluenceAmount, bassInfluenceAmount) * distanceInfluenceFactor;

                this.targetSize = (this.baseSize * 0.5) + (this.baseSize * 9.0 * totalAudioInfluence);
                let targetBrightness = (totalAudioInfluence > 0) ? 1.0 : 0.5;

                let lerpFactorBrightness = 0.1;
                if (targetBrightness < this.currentBrightnessFactor) {
                    lerpFactorBrightness = 0.3;
                }
                this.currentBrightnessFactor = lerp(this.currentBrightnessFactor, targetBrightness, lerpFactorBrightness);

                let lerpFactorSize;
                if (this.targetSize > this.size) {
                    lerpFactorSize = 0.1;
                } else {
                    lerpFactorSize = 0.3;
                }
                this.size = lerp(this.size, this.targetSize, lerpFactorSize);
            }

            display(graphicsBuffer, zoomMultiplier, zoomGradientFactor, zoomStrokeMultiplier) {
                if (awakeningState === 'awakening' || awakeningState === 'active') {
                    graphicsBuffer.push();
                    graphicsBuffer.strokeWeight(map(this.currentBrightnessFactor, 0.5, 1.0, 0.5, 1.2) * zoomStrokeMultiplier);

                    const whiteColor = color(255);
                    const particleColor = color(this.originalRGB[0], this.originalRGB[1], this.originalRGB[2]);
                    const finalColor = lerpColor(particleColor, whiteColor, zoomGradientFactor);
                    
                    const idleAlpha = 50;
                    const activeAlpha = map(this.currentBrightnessFactor, 0.5, 1.0, idleAlpha, this.maxOpacity);
                    const transitionAlpha = easeInOutCubic(transitionProgress / sphereTransitionDuration) * idleAlpha;
                    const finalAlpha = (awakeningState === 'awakening') ? transitionAlpha : activeAlpha;


                    graphicsBuffer.stroke(red(finalColor), green(finalColor), blue(finalColor), finalAlpha);
                    graphicsBuffer.line(0, 0, 0, this.pos.x, this.pos.y, this.pos.z);
                    graphicsBuffer.pop();

                    if (awakeningState === 'active' && this.flowDirection !== 0) {
                        graphicsBuffer.push();
                        graphicsBuffer.blendMode(ADD);
                        let centerPoint = createVector(0, 0, 0);
                        for (let flowEl of this.flowingElements) {
                            let pFlow = (this.flowDirection === 1) ?
                                p5.Vector.lerp(centerPoint, this.pos, flowEl.offset) :
                                p5.Vector.lerp(this.pos, centerPoint, 1 - flowEl.offset);

                            let flowProgressAlpha = (this.flowDirection === -1) ? 1 - flowEl.offset : flowEl.offset;
                            let flowAlpha = 255;
                            if (flowProgressAlpha < 0.1) flowAlpha = map(flowProgressAlpha, 0, 0.1, 100, 255);
                            else if (flowProgressAlpha > 0.9) flowAlpha = map(flowProgressAlpha, 0.9, 1, 255, 100);

                            flowAlpha = constrain(this.currentBrightnessFactor * flowAlpha, 0, 255);
                            
                            let sizeMultiplier = map(this.currentBrightnessFactor, 0.5, 1.0, 0.5, 1.0, true);
                            let displaySize = flowEl.size * sizeMultiplier * zoomMultiplier;

                            graphicsBuffer.noStroke();
                            graphicsBuffer.fill(this.originalRGB[0], this.originalRGB[1], this.originalRGB[2], flowAlpha);
                            graphicsBuffer.push();
                            graphicsBuffer.translate(pFlow.x, pFlow.y, pFlow.z);
                            graphicsBuffer.sphere(displaySize);
                            graphicsBuffer.pop();
                        }
                        graphicsBuffer.pop();
                    }
                }

                // Draw the main solid sphere (always visible)
                graphicsBuffer.push();
                graphicsBuffer.translate(this.pos.x, this.pos.y, this.pos.z);
                graphicsBuffer.noStroke();
                graphicsBuffer.fill(this.originalRGB[0] * this.currentBrightnessFactor,
                                     this.originalRGB[1] * this.currentBrightnessFactor,
                                     this.originalRGB[2] * this.currentBrightnessFactor, 255);
                graphicsBuffer.sphere(this.size);
                graphicsBuffer.pop();
            }
        }
        
        function setup() {
            createCanvas(windowWidth, windowHeight, WEBGL);
            pixelDensity(1);

            mainSceneBuffer = createGraphics(width, height, WEBGL);
            mainSceneBuffer.pixelDensity(1);

            maxZoom = (height / 2) / tan(PI / 6);
            minZoom = centralSphereSize + 50;
            cameraZ = maxZoom;
            targetCameraZ = cameraZ;
            
            currentCentralSphereSize = 80;
            const initialShellRadius = 90;
            const phi = PI * (3.0 - sqrt(5.0)); 

            for (let i = 0; i < numParticles; i++) {
                let y = 1 - (i / (numParticles - 1)) * 2; 
                let radius = sqrt(1 - y * y); 
                let theta = phi * i; 
                let x = cos(theta) * radius;
                let z = sin(theta) * radius;
                const initialPos = createVector(x, y, z).mult(initialShellRadius);

                const initialDirection = initialPos.copy().normalize();
                const targetMaxOrbit = random(170, 300);
                const targetMinOrbit = 160;
                const targetRadius = map(pow(random(1), 2), 0, 1, targetMinOrbit, targetMaxOrbit);
                const targetPos = initialDirection.mult(targetRadius);
                
                particles.push(new ParticleSphere(initialPos, targetPos));
            }
            
            star = new Star();

            startButton = document.getElementById('startButton');
            startButton.addEventListener('click', startAudio);

            targetSceneRotationX = sceneRotationX;
            targetSceneRotationY = sceneRotationY;
        }

        function mouseWheel(event) {
            targetCameraZ += event.delta * 0.75;
            targetCameraZ = constrain(targetCameraZ, minZoom, maxZoom);
            return false;
        }

        function mousePressed() {
            isDragging = true;
            prevMouseX = mouseX;
            prevMouseY = mouseY;
        }

        function mouseReleased() {
            isDragging = false;
        }

        function mouseDragged() {
            if (isDragging) {
                let dx = mouseX - prevMouseX;
                let dy = mouseY - prevMouseY;
                targetSceneRotationY += dx * 0.005;
                targetSceneRotationX -= dy * 0.005;
                prevMouseX = mouseX;
                prevMouseY = mouseY;
            }
        }

        function touchStarted(event) {
            if (event.target.tagName === 'CANVAS') {
                if (touches.length > 0) {
                    isDragging = true;
                    prevMouseX = touches[0].x;
                    prevMouseY = touches[0].y;
                }
                return false;
            }
        }

        function touchEnded(event) {
            isDragging = false;
            if (event.target.tagName === 'CANVAS') {
                return false;
            }
        }

        function touchMoved(event) {
            if (isDragging && touches.length > 0) {
                let dx = touches[0].x - prevMouseX;
                let dy = touches[0].y - prevMouseY;
                targetSceneRotationY += dx * 0.005;
                targetSceneRotationX -= dy * 0.005;
                prevMouseX = touches[0].x;
                prevMouseY = touches[0].y;
            }
            if (event.target.tagName === 'CANVAS') {
                return false;
            }
        }

        function startAudio() {
            if (awakeningState !== 'dormant') return;
            
            awakeningState = 'awakening'; // Start the transition
            startButton.disabled = true;

            if (getAudioContext().state === 'suspended') {
                getAudioContext().resume();
            }
            mic = new p5.AudioIn();
            fft = new p5.FFT(0.8, 128);
            fft.setInput(mic);
            mic.start(() => {
                // Audio is ready, but we wait for the transition to finish
            }, (err) => {
                console.error("Microphone access error:", err);
                showMessageBox("Microphone access denied or not available. Please allow microphone access to enable voice reactivity.");
            });
        }

        // Easing function for a smooth transition
        function easeInOutCubic(t) {
            return t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
        }

        function windowResized() {
            resizeCanvas(windowWidth, windowHeight);
            mainSceneBuffer = createGraphics(width, height, WEBGL);
            mainSceneBuffer.pixelDensity(1);
            maxZoom = (height / 2) / tan(PI / 6);
            cameraZ = constrain(cameraZ, minZoom, maxZoom);
            targetCameraZ = constrain(targetCameraZ, minZoom, maxZoom);
        }

        function draw() {
            mainSceneBuffer.background(0, 0);
            mainSceneBuffer.push();

            cameraZ = lerp(cameraZ, targetCameraZ, zoomLerpFactor);
            mainSceneBuffer.camera(0, 0, cameraZ, 0, 0, 0, 0, 1, 0);

            sceneRotationX = lerp(sceneRotationX, targetSceneRotationX, rotationLerpFactor);
            sceneRotationY = lerp(sceneRotationY, targetSceneRotationY, rotationLerpFactor);
            mainSceneBuffer.rotateX(sceneRotationX);
            mainSceneBuffer.rotateY(sceneRotationY);
            let rotationSpeedFactor = 0.005;
            let noiseIncrement = 0.005;
            sceneRotationZ += map(noise(sceneNoiseOffsetZ), 0, 1, -rotationSpeedFactor, rotationSpeedFactor);
            sceneNoiseOffsetZ += noiseIncrement;
            mainSceneBuffer.rotateZ(sceneRotationZ);

            let blackSphereAlpha = map(cameraZ, minZoom, maxZoom, 0, 255, true);
            let zoomSizeMultiplier = map(cameraZ, maxZoom, minZoom, 1.0, 0.5, true);
            const gradientStartZoom = lerp(maxZoom, minZoom, 0.66);
            let zoomGradientFactor = map(cameraZ, gradientStartZoom, minZoom, 0, 1, true);
            let zoomStrokeMultiplier = map(cameraZ, maxZoom, minZoom, 1.0, 0.5, true);
            
            if (awakeningState === 'awakening') {
                transitionProgress++;
                if (transitionProgress >= sphereTransitionDuration) {
                    awakeningState = 'active';
                    audioStarted = true;
                }
                
                const blackSphereProgress = min(1, transitionProgress / blackSphereTransitionDuration);
                currentCentralSphereSize = lerp(80, centralSphereSize, easeInOutCubic(blackSphereProgress));
            }

            if (audioStarted) {
                if (mic && mic.enabled && getAudioContext().state === 'running') {
                    currentVolume = mic.getLevel();
                    fft.analyze();
                    bassEnergy = fft.getEnergy('bass');
                } else {
                    currentVolume = 0.0;
                    bassEnergy = 0;
                }
                audioHistory.push({ volume: currentVolume, bass: bassEnergy });
                if (audioHistory.length > historyLength) {
                    audioHistory.shift();
                }

                let effectiveVolumeCentral = (currentVolume > minActivationVolume) ? currentVolume : 0;
                let effectiveBassEnergyCentral = (bassEnergy > minActivationBass) ? bassEnergy : 0;
                let targetCentralSphereSize = 150;
                targetCentralSphereSize += map(effectiveVolumeCentral, minActivationVolume, 0.6, 0, 112.5, true);
                targetCentralSphereSize += map(effectiveBassEnergyCentral, minActivationBass, 200, 0, 45, true);

                star.update();
                star.applyAudioInfluence(currentVolume, bassEnergy);
                star.display(mainSceneBuffer);

                for (let particle of particles) {
                    particle.update();
                    particle.applyAudioInfluence(audioHistory);
                    particle.display(mainSceneBuffer, zoomSizeMultiplier, zoomGradientFactor, zoomStrokeMultiplier);
                }

                mainSceneBuffer.push();
                mainSceneBuffer.noStroke();
                mainSceneBuffer.fill(0, blackSphereAlpha);
                mainSceneBuffer.sphere(targetCentralSphereSize, centralSphereDetailX, centralSphereDetailY);
                mainSceneBuffer.pop();
            } else {
                while (audioHistory.length < historyLength) {
                    audioHistory.push({ volume: 0.0, bass: 0 });
                }
                while (audioHistory.length > historyLength) {
                    audioHistory.shift();
                }
                
                star.update();
                star.applyAudioInfluence(0,0);
                star.display(mainSceneBuffer);

                for (let particle of particles) {
                    particle.update();
                    particle.applyAudioInfluence(audioHistory);
                    particle.display(mainSceneBuffer, zoomSizeMultiplier, zoomGradientFactor, zoomStrokeMultiplier);
                }
                mainSceneBuffer.push();
                mainSceneBuffer.noStroke();
                mainSceneBuffer.fill(0, blackSphereAlpha);
                mainSceneBuffer.sphere(currentCentralSphereSize, centralSphereDetailX, centralSphereDetailY);
                mainSceneBuffer.pop();
            }
            mainSceneBuffer.pop();

            background(0);
            image(mainSceneBuffer, -width / 2, -height / 2);
        }
    </script>
</body>
</html>
