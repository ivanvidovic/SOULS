<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Voice Reactive Digital Soul</title>
    <!-- Tailwind CSS CDN for basic styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- p5.js library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.2/p5.min.js"></script>
    <!-- p5.sound.js library for audio input -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.2/addons/p5.sound.min.js"></script>
    <style>
        body {
            margin: 0;
            overflow: hidden; /* Hide scrollbars */
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background-color: #000000; /* Solid Black Background */
            font-family: "Inter", sans-serif;
            color: #e0e0e0;
        }
        canvas {
            display: block;
            border-radius: 1rem; /* Rounded corners for the canvas */
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.5); /* Glowing effect */
            max-width: 100vw; /* Ensure canvas fits screen width */
            max-height: 100vh; /* Ensure canvas fits screen height */
        }
        #controls {
            position: absolute;
            top: 1rem;
            left: 50%;
            transform: translateX(-50%);
            z-index: 10;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0.5rem; /* Space between buttons/messages */
        }
        button {
            background-color: #0f3460;
            color: #e94560;
            padding: 0.75rem 1.5rem;
            border-radius: 0.75rem;
            border: 2px solid #e94560;
            cursor: pointer;
            font-size: 1rem;
            font-weight: bold;
            transition: all 0.3s ease;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.2);
        }
        button:hover {
            background-color: #e94560;
            color: #0f3460;
            box-shadow: 0 6px 8px rgba(0, 0, 0, 0.3);
            transform: translateY(-2px);
        }
        button:disabled {
            background-color: #3a3a5a;
            color: #999;
            border-color: #555;
            cursor: not-allowed;
            box-shadow: none;
            transform: none;
        }
        #message-box {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.7);
            z-index: 1000;
            display: none; /* Hidden by default */
            text-align: center;
            max-width: 80%;
        }
        #message-box button {
            margin-top: 15px;
            background-color: #e94560;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
        }
        #message-box button:hover {
            background-color: #c0392b;
        }
    </style>
</head>
<body>
    <div id="controls">
        <button id="startButton">Start Audio Visualization</button>
        <p id="statusMessage" class="mt-2 text-sm text-gray-400">Click 'Start Audio Visualization' to begin.</p>
    </div>

    <div id="message-box">
        <p id="message-content"></p>
        <button onclick="hideMessageBox()">OK</button>
    </div>

    <script>
        let mic;
        let fft;
        let particles = [];
        const numParticles = 200; // Number of small orbiting spheres
        let centralSphereSize = 150; // Base size for scaling
        let currentVolume = 0;
        let bassEnergy = 0;
        let midEnergy = 0;
        let trebleEnergy = 0;
        let audioStarted = false; // Flag to track if audio (mic) has started
        let statusMessage;
        let startButton;

        // Global scene rotation variables for X, Y, Z axes
        let sceneRotationX = 0;
        let sceneRotationY = 0;
        let sceneRotationZ = 0;
        let sceneNoiseOffsetX = 10000; // Unique noise offsets for independent rotation
        let sceneNoiseOffsetY = 0;
        let sceneNoiseOffsetZ = 20000;

        // Audio history for delayed response
        let audioHistory = [];
        const historyLength = 15; // Reduced from 40 for more immediate reaction (approx 0.25 seconds)
        // Define sensitivity thresholds (reverted to original)
        const minActivationVolume = 0.15;
        const minActivationBass = 120;

        // Fixed detail for the chunky central sphere
        const centralSphereDetailX = 24;
        const centralSphereDetailY = 16;

        // Define the custom hex colors for the small spheres
        const sphereColors = [
            [197, 62, 192], // #C53EC0 (Purple)
            [66, 255, 255],  // #42FFFF (Cyan)
            [182, 147, 154], // #B6939A (Rose Gray)
            [47, 28, 114],   // #2F1C72 (Dark Indigo)
            [255, 89, 126]   // #FF597E (Pink Red)
        ];

        // p5.Graphics buffer for chromatic aberration
        let mainSceneBuffer;

        // Function to display custom messages
        function showMessageBox(message) {
            document.getElementById('message-content').innerText = message;
            document.getElementById('message-box').style.display = 'block';
        }

        // Function to hide custom messages
        function hideMessageBox() {
            document.getElementById('message-box').style.display = 'none';
        }

        // ParticleSphere class definition
        class ParticleSphere {
            constructor() {
                // Define the desired orbit range for particles
                this.minOrbitRadius = 100;
                this.maxOrbitRadius = 250; // Reduced from 350 to keep spheres closer

                // Initial position in 3D space, with a bias towards minOrbitRadius
                let initialRadius = map(pow(random(1), 2), 0, 1, this.minOrbitRadius, this.maxOrbitRadius);
                this.pos = p5.Vector.random3D().mult(initialRadius);

                // Varied initial velocity for "more energy"
                this.vel = p5.Vector.random3D().mult(random(0.05, 0.2)); // Adjusted range for slower starts and variation
                this.acc = createVector(0, 0, 0);

                // Base size is now much smaller for idle state
                this.baseSize = random(1, 4); // Reduced from random(5, 12.5) for smaller idle particles
                this.size = this.baseSize * 0.5; // Initial size is 50% of base size
                this.targetSize = this.baseSize * 0.5; // Target size for lerping

                // Randomly assign one of the custom colors
                this.originalRGB = sphereColors[floor(random(sphereColors.length))];
                this.currentBrightnessFactor = 0.5; // Initial brightness factor (50%)

                this.noiseOffset = random(1000);

                // Varied max speed and max force for "more energy"
                this.maxSpeed = random(0.8, 1.5); // Increased for more noticeable movement
                this.maxForce = random(0.04, 0.08); // Increased for more responsiveness to forces

                // Properties for particle internal glows
                this.positionHistory = []; // To store previous positions for glows
                this.historyLength = 8; // Number of previous positions to store
            }

            // Apply a force to the particle
            applyForce(force) {
                this.acc.add(force);
            }

            // Update position based on velocity, apply noise, and orbit forces
            update() {
                // Apply noise-based "random" movement in 3D (noiseFactor reduced for slower changes)
                let noiseFactor = 0.001;
                let nx = map(noise(this.noiseOffset, frameCount * noiseFactor, 0), 0, 1, -this.maxForce, this.maxForce);
                let ny = map(noise(this.noiseOffset + 1000, frameCount * noiseFactor, 0), 0, 1, -this.maxForce, this.maxForce);
                let nz = map(noise(this.noiseOffset + 2000, frameCount * noiseFactor, 0), 0, 1, -this.maxForce, this.maxForce);
                this.applyForce(createVector(nx, ny, nz));

                // Force to keep particles within the desired orbit radius
                let currentDistance = this.pos.mag();
                if (currentDistance > this.maxOrbitRadius) {
                    let steer = p5.Vector.sub(createVector(0,0,0), this.pos);
                    // Adjust pull strength to be effective within the new, smaller maxOrbitRadius
                    steer.setMag(map(currentDistance, this.maxOrbitRadius, this.maxOrbitRadius + 50, 0, this.maxForce * 0.7)); // Adjusted outer bound
                    this.applyForce(steer);
                } else if (currentDistance < this.minOrbitRadius) {
                    let steer = p5.Vector.sub(this.pos, createVector(0,0,0));
                    // Adjust push strength to be effective within the new, smaller minOrbitRadius
                    steer.setMag(map(currentDistance, this.minOrbitRadius, this.minOrbitRadius - 50, 0, this.maxForce * 0.7)); // Adjusted inner bound
                    this.applyForce(steer);
                }

                // Add a gentle orbiting force (tangential force)
                let tangentialForce = createVector(-this.pos.y, this.pos.x, this.pos.z * 0.1).normalize(); // Bias towards XY plane orbit
                tangentialForce.mult(this.maxForce * 0.2); // Increased orbiting influence
                this.applyForce(tangentialForce);

                this.vel.add(this.acc);
                this.vel.limit(this.maxSpeed);
                this.pos.add(this.vel);
                this.acc.mult(0);

                // Apply damping to velocity for smoother movement
                this.vel.mult(0.95);

                // Store current position in history for internal glows
                this.positionHistory.push(this.pos.copy());
                if (this.positionHistory.length > this.historyLength) {
                    this.positionHistory.shift(); // Remove the oldest position
                }
            }

            // Update particle size and brightness based on audio input history
            applyAudioInfluence(history) {
                let currentDistance = this.pos.mag();

                // Taper off voice effect based on distance
                let distanceInfluenceFactor = map(currentDistance, this.minOrbitRadius, this.maxOrbitRadius, 1.0, 0.1, true); // Taper to 0.1 at max distance

                // Calculate delay based on distance
                let delayFrames = map(currentDistance, this.minOrbitRadius, this.maxOrbitRadius, 0, historyLength - 1);
                delayFrames = floor(constrain(delayFrames, 0, historyLength - 1));

                // Get delayed audio data from history
                let delayedAudio = history[(historyLength - 1) - delayFrames];
                if (!delayedAudio) {
                    delayedAudio = { volume: 0, bass: 0 };
                }

                // Apply activation threshold to the delayed audio data
                let effectiveAmplitude = (delayedAudio.volume > minActivationVolume) ? delayedAudio.volume : 0;
                let effectiveBass = (delayedAudio.bass > minActivationBass) ? delayedAudio.bass : 0;

                // Adjust sensitivity and range for volume influence (for brightness and size)
                let volumeInfluenceAmount = map(effectiveAmplitude, minActivationVolume, 0.6, 0, 1, true); // Maps to 0-1 for influence
                let bassInfluenceAmount = map(effectiveBass, minActivationBass, 200, 0, 1, true); // Maps to 0-1 for influence

                // Combine influences for overall audio reactivity
                let totalAudioInfluence = max(volumeInfluenceAmount, bassInfluenceAmount); // Take the max influence
                totalAudioInfluence *= distanceInfluenceFactor;

                // Set target size: 1.0 (full) if reacting, 0.5 (50% darker) if not
                this.targetSize = (this.baseSize * 0.5) + (this.baseSize * 9.0 * totalAudioInfluence); // Scales up to baseSize * 9.5 when fully active

                // Set target brightness: 1.0 (full) if reacting, 0.5 (50% darker) if not
                let targetBrightness = (totalAudioInfluence > 0) ? 1.0 : 0.5;


                // Dynamic lerp for quick smooth bring down (for brightness)
                let lerpFactorBrightness = 0.1;
                if (targetBrightness < this.currentBrightnessFactor) {
                    lerpFactorBrightness = 0.3; // Faster dimming
                }
                this.currentBrightnessFactor = lerp(this.currentBrightnessFactor, targetBrightness, lerpFactorBrightness);

                // Size lerping
                let lerpFactorSize;
                if (this.targetSize > this.size) { // Growing (faster)
                    lerpFactorSize = 0.1; // Faster growth
                } else { // Shrinking (faster)
                    lerpFactorSize = 0.3; // Faster shrinking
                }
                this.size = lerp(this.size, this.targetSize, lerpFactorSize);
            }

            // Display the particle sphere and its internal glows
            display(graphicsBuffer) { // Accept graphicsBuffer as an argument
                // Calculate scaled RGB for glows
                // When currentBrightnessFactor is 0.5, scale by 1.0 (no change from original color)
                // When currentBrightnessFactor is 1.0, scale by 2.0 (100% brighter color)
                let glowR = this.originalRGB[0] * map(this.currentBrightnessFactor, 0.5, 1.0, 1.0, 2.0, true);
                let glowG = this.originalRGB[1] * map(this.currentBrightnessFactor, 0.5, 1.0, 1.0, 2.0, true);
                let glowB = this.originalRGB[2] * map(this.currentBrightnessFactor, 0.5, 1.0, 1.0, 2.0, true);

                // Ensure RGB values don't exceed 255
                glowR = constrain(glowR, 0, 255);
                glowG = constrain(glowG, 0, 255);
                glowB = constrain(glowB, 0, 255);

                // Draw internal glows (from position history, now local to particle)
                for (let i = 0; i < this.positionHistory.length; i++) {
                    let p = this.positionHistory[i];
                    // Alpha scales with age and particle's current brightness, capped at 255
                    let alpha = map(i, 0, this.historyLength, 0, this.currentBrightnessFactor * 255); // Max 255
                    alpha = constrain(alpha, 0, 255); // Ensure alpha is capped

                    graphicsBuffer.push();
                    graphicsBuffer.noStroke();
                    graphicsBuffer.fill(glowR, glowG, glowB, alpha); // Use scaled RGB for glow
                    graphicsBuffer.blendMode(ADD);
                    graphicsBuffer.sphere(map(i, 0, this.historyLength, this.size * 0.1, this.size * 0.6));
                    graphicsBuffer.pop();
                }

                // Draw the energy line connecting to the center
                graphicsBuffer.push();
                graphicsBuffer.stroke(this.originalRGB[0], this.originalRGB[1], this.originalRGB[2], this.currentBrightnessFactor * 100); // Color and opacity based on particle brightness
                graphicsBuffer.strokeWeight(map(this.currentBrightnessFactor, 0.5, 1.0, 0.5, 2.5)); // Thickness reacts to brightness
                graphicsBuffer.line(this.pos.x, this.pos.y, this.pos.z, 0, 0, 0); // Line from particle to origin
                graphicsBuffer.pop();

                // Draw the main solid sphere
                graphicsBuffer.push(); // Use graphicsBuffer
                graphicsBuffer.translate(this.pos.x, this.pos.y, this.pos.z); // Use graphicsBuffer
                graphicsBuffer.noStroke(); // Use graphicsBuffer

                // Draw feathered glow layers (behind the main solid sphere)
                graphicsBuffer.blendMode(ADD); // Ensure additive blending for glow
                for (let i = 0; i < 5; i++) { // Draw 5 layers for feathered effect
                    let featherSize = this.size * (1.8 + i * 0.3); // Gradually larger
                    let featherAlpha = map(i, 0, 4, this.currentBrightnessFactor * 100, 0); // Fading alpha
                    featherAlpha = constrain(featherAlpha, 0, 255); // Cap alpha

                    graphicsBuffer.push();
                    graphicsBuffer.fill(glowR, glowG, glowB, featherAlpha); // Use scaled RGB for glow
                    graphicsBuffer.sphere(featherSize);
                    graphicsBuffer.pop();
                }

                // Draw the main solid sphere (its color is already scaled by currentBrightnessFactor)
                graphicsBuffer.fill(this.originalRGB[0] * this.currentBrightnessFactor, // Use graphicsBuffer
                     this.originalRGB[1] * this.currentBrightnessFactor, // Use graphicsBuffer
                     this.originalRGB[2] * this.currentBrightnessFactor, 255); // Explicitly opaque // Use graphicsBuffer
                graphicsBuffer.sphere(this.size); // Use graphicsBuffer
                graphicsBuffer.pop(); // Use graphicsBuffer
            }
        }


        // p5.js setup function
        function setup() {
            createCanvas(windowWidth, windowHeight, WEBGL);
            pixelDensity(1);

            // Initialize the off-screen graphics buffer
            mainSceneBuffer = createGraphics(width, height, WEBGL);

            for (let i = 0; i < numParticles; i++) {
                particles.push(new ParticleSphere());
            }

            statusMessage = document.getElementById('statusMessage');
            startButton = document.getElementById('startButton');
            startButton.addEventListener('click', startAudio);
        }

        // Function to start audio context (microphone)
        function startAudio() {
            if (audioStarted) return;

            mic = new p5.AudioIn();
            fft = new p5.FFT(0.8, 128);
            fft.setInput(mic);

            mic.start(() => {
                if (getAudioContext().state !== 'running') {
                    getAudioContext().resume();
                }
                audioStarted = true;
                startButton.disabled = true;
                statusMessage.innerText = 'Microphone active! Speak to see the animation react.';
            }, (err) => {
                console.error("Microphone access error:", err);
                showMessageBox("Microphone access denied or not available. Please allow microphone access to enable voice reactivity.");
                statusMessage.innerText = 'Microphone access denied. Animation will run statically.';
                audioStarted = true;
                this.startButton.disabled = true; // Ensure button is disabled even on error
            });
        }

        // Handle window resizing
        function windowResized() {
            resizeCanvas(windowWidth, windowHeight);
            // Also resize the off-screen buffer
            mainSceneBuffer = createGraphics(width, height, WEBGL);
        }

        // p5.js draw function
        function draw() {
            // --- Render the entire scene to the off-screen buffer ---
            mainSceneBuffer.background(0, 0); // Clear buffer with transparent black
            mainSceneBuffer.push(); // Push matrix for buffer's transformations
            mainSceneBuffer.rotateX(sceneRotationX);
            mainSceneBuffer.rotateY(sceneRotationY);
            mainSceneBuffer.rotateZ(sceneRotationZ);

            if (audioStarted) {
                if (mic && mic.enabled && getAudioContext().state === 'running') {
                    currentVolume = mic.getLevel();
                    let spectrum = fft.analyze();
                    bassEnergy = fft.getEnergy('bass');
                    midEnergy = 0; // Not used for visual reaction in this mode
                    trebleEnergy = 0; // Not used for visual reaction in this mode
                } else {
                    currentVolume = 0.0;
                    bassEnergy = 0;
                    midEnergy = 0;
                    trebleEnergy = 0;
                }

                // Store current audio data in history
                audioHistory.push({ volume: currentVolume, bass: bassEnergy, mid: midEnergy, treble: trebleEnergy });
                if (audioHistory.length > historyLength) {
                    audioHistory.shift();
                }

                // Central sphere reaction to current audio data (no delay for central sphere)
                let effectiveVolumeCentral = (currentVolume > minActivationVolume) ? currentVolume : 0;
                let effectiveBassEnergyCentral = (bassEnergy > minActivationBass) ? bassEnergy : 0;

                let targetCentralSphereSize = 150; // Base size for central sphere
                // Increased central sphere scaling by 50%
                targetCentralSphereSize += map(effectiveVolumeCentral, minActivationVolume, 0.6, 0, 112.5, true); // 75 * 1.5 = 112.5
                targetCentralSphereSize += map(effectiveBassEnergyCentral, minActivationBass, 200, 0, 45, true); // 30 * 1.5 = 45


                // Draw small spheres first
                for (let i = 0; i < numParticles; i++) {
                    particles[i].update();
                    particles[i].applyAudioInfluence(audioHistory); // Pass the entire history
                    particles[i].display(mainSceneBuffer); // Pass the buffer here
                }

                // Draw the main black central sphere (on top of small spheres)
                mainSceneBuffer.push();
                mainSceneBuffer.noStroke();
                mainSceneBuffer.fill(0, 255); // Solid black fill
                mainSceneBuffer.sphere(targetCentralSphereSize, centralSphereDetailX, centralSphereDetailY);
                mainSceneBuffer.pop();


            } else {
                // Static animation if audio not started
                // Draw small spheres first
                // Ensure audioHistory is filled with default values if not already
                while (audioHistory.length < historyLength) {
                    audioHistory.push({ volume: 0.0, bass: 0, mid: 0, treble: 0 });
                }
                // If it somehow grew too large in a weird scenario, trim it
                while (audioHistory.length > historyLength) {
                    audioHistory.shift();
                }

                for (let i = 0; i < numParticles; i++) {
                    particles[i].update();
                    // For static mode, pass the history which is now filled with zeros
                    particles[i].applyAudioInfluence(audioHistory);
                    particles[i].display(mainSceneBuffer); // Pass the buffer here
                }

                // Draw the main black central sphere (on top of small spheres)
                mainSceneBuffer.push();
                mainSceneBuffer.noStroke();
                mainSceneBuffer.fill(0, 255); // Solid black fill
                mainSceneBuffer.sphere(centralSphereSize, centralSphereDetailX, centralSphereDetailY);
                mainSceneBuffer.pop();
            }
            mainSceneBuffer.pop(); // Pop matrix to end rotation for the entire scene in the buffer

            // --- Apply global scene rotation on all axes for the next frame ---
            let rotationSpeedFactor = 0.005; // Base speed for overall scene rotation
            let noiseIncrement = 0.005; // How fast noise changes

            sceneRotationY += map(noise(sceneNoiseOffsetY), 0, 1, -rotationSpeedFactor, rotationSpeedFactor);
            sceneNoiseOffsetY += noiseIncrement;

            sceneRotationX += map(noise(sceneNoiseOffsetX), 0, 1, -rotationSpeedFactor, rotationSpeedFactor);
            sceneNoiseOffsetX += noiseIncrement;

            sceneRotationZ += map(noise(sceneNoiseOffsetZ), 0, 1, -rotationSpeedFactor, rotationSpeedFactor);
            sceneNoiseOffsetZ += noiseIncrement;


            // --- Draw the buffer to the main canvas with chromatic aberration ---
            background(0); // Clear the main canvas
            blendMode(ADD); // Enable additive blending

            // Calculate chromatic aberration offset based on audio volume
            let ab_offset_base = 1.5; // Reverted to original 1.5
            let ab_offset_audio_scale = map(currentVolume, minActivationVolume, 0.6, 0, 5.0, true); // Kept at 5.0
            let ab_offset = ab_offset_base + ab_offset_audio_scale;

            // Draw red channel
            tint(255, 0, 0);
            image(mainSceneBuffer, -width / 2 - ab_offset, -height / 2); // Corrected positioning for WEBGL

            // Draw green channel (no offset, as it's the center)
            tint(0, 255, 0);
            image(mainSceneBuffer, -width / 2, -height / 2); // Corrected positioning for WEBGL

            // Draw blue channel
            tint(0, 0, 255);
            image(mainSceneBuffer, -width / 2 + ab_offset, -height / 2); // Corrected positioning for WEBGL

            blendMode(BLEND); // Reset blend mode to default for future drawings
        }
    </script>
</body>
</html>
