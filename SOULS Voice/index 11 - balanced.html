<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-F-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Voice Reactive Digital Soul</title>
    <!-- Tailwind CSS CDN for basic styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- p5.js library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.2/p5.min.js"></script>
    <!-- p5.sound.js library for audio input -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.2/addons/p5.sound.min.js"></script>
    <style>
        body {
            margin: 0;
            overflow: hidden; /* Hide scrollbars */
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background-color: #000000; /* Solid Black Background */
            font-family: "Inter", sans-serif;
            color: #e0e0e0;
        }
        canvas {
            display: block;
            border-radius: 1rem; /* Rounded corners for the canvas */
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.5); /* Glowing effect */
            max-width: 100vw; /* Ensure canvas fits screen width */
            max-height: 100vh; /* Ensure canvas fits screen height */
        }
        #controls {
            position: absolute;
            top: 1rem;
            left: 50%;
            transform: translateX(-50%);
            z-index: 10;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        button {
            background-color: #0f3460;
            color: #ffffff; /* Icon color is now white */
            width: 2.25rem; /* Decreased size by 25% */
            height: 2.25rem; /* Decreased size by 25% */
            border-radius: 50%; /* Makes the button a perfect circle */
            border: 2px solid #ffffff; /* Border is now white */
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.2);
            display: flex;
            align-items: center;
            justify-content: center;
        }
        button:hover {
            background-color: #e94560; /* Hover fill is red */
            border-color: #e94560; /* Hover border is red */
            color: #ffffff; /* Hover icon is white */
            box-shadow: 0 6px 8px rgba(0, 0, 0, 0.3);
            /* Removed transform so it doesn't move */
        }
        button:disabled {
            background-color: #3a3a5a;
            color: #999;
            border-color: #555;
            cursor: not-allowed;
            box-shadow: none;
            transform: none;
        }
        #message-box {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.7);
            z-index: 1000;
            display: none; /* Hidden by default */
            text-align: center;
            max-width: 80%;
        }
        #message-box button {
            margin-top: 15px;
            background-color: #e94560;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
        }
        #message-box button:hover {
            background-color: #c0392b;
        }
    </style>
</head>
<body>
    <div id="controls">
        <button id="startButton" aria-label="Activate Mic">
            <!-- SVG Microphone Icon -->
            <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z"></path>
                <path d="M19 10v2a7 7 0 0 1-14 0v-2"></path>
                <line x1="12" y1="19" x2="12" y2="23"></line>
                <line x1="8" y1="23" x2="16" y2="23"></line>
            </svg>
        </button>
    </div>

    <div id="message-box">
        <p id="message-content"></p>
        <button onclick="hideMessageBox()">OK</button>
    </div>

    <script>
        let mic;
        let fft;
        let particles = []; // For the orbiting spheres with lines
        let centralClusterSpheres = []; // For the central cluster of spheres
        // Restored original particle counts
        const numParticles = 200;
        const numCentralClusterSpheres = 300;
        let centralSphereSize = 150; // Base size for scaling
        let currentVolume = 0;
        let bassEnergy = 0;
        let midEnergy = 0;
        let trebleEnergy = 0;
        let audioStarted = false; // Flag to track if audio (mic) has started
        let startButton;

        // Global scene rotation variables for X, Y, Z axes
        let sceneRotationX = 0;
        let sceneRotationY = 0;
        let sceneRotationZ = 0;
        let sceneNoiseOffsetX = 10000;
        let sceneNoiseOffsetY = 0;
        let sceneNoiseOffsetZ = 20000;

        // Variables for interactive orbiting controls
        let targetSceneRotationX = 0;
        let targetSceneRotationY = 0;
        const rotationLerpFactor = 0.08;
        let isDragging = false;
        let prevMouseX = 0;
        let prevMouseY = 0;

        // Audio history for delayed response
        // Restored original history length
        let audioHistory = [];
        const historyLength = 15;
        const minActivationVolume = 0.15;
        const minActivationBass = 120;

        // Fixed detail for the chunky central sphere
        const centralSphereDetailX = 24;
        const centralSphereDetailY = 16;

        // Define the custom hex colors for the small spheres
        const sphereColors = [
            [197, 62, 192], // #C53EC0 (Purple)
            [66, 255, 255],  // #42FFFF (Cyan)
            [182, 147, 154], // #B6939A (Rose Gray)
            [47, 28, 114],   // #2F1C72 (Dark Indigo)
            [255, 89, 126]   // #FF597E (Pink Red)
        ];

        // p5.Graphics buffer for off-screen rendering
        let mainSceneBuffer;

        function showMessageBox(message) {
            document.getElementById('message-content').innerText = message;
            document.getElementById('message-box').style.display = 'block';
        }

        function hideMessageBox() {
            document.getElementById('message-box').style.display = 'none';
        }

        class ParticleSphere {
            constructor() {
                this.minOrbitRadius = 100;
                this.maxOrbitRadius = 250;
                let initialRadius = map(pow(random(1), 2), 0, 1, this.minOrbitRadius, this.maxOrbitRadius);
                this.pos = p5.Vector.random3D().mult(initialRadius);
                this.vel = p5.Vector.random3D().mult(random(0.05, 0.2));
                this.acc = createVector(0, 0, 0);
                this.baseSize = random(1, 4);
                this.size = this.baseSize * 0.5;
                this.targetSize = this.baseSize * 0.5;
                this.originalRGB = sphereColors[floor(random(sphereColors.length))];
                this.currentBrightnessFactor = 0.5;
                this.noiseOffset = random(1000);
                this.maxSpeed = random(0.8, 1.5);
                this.maxForce = random(0.04, 0.08);
                this.positionHistory = [];
                this.historyLength = 8;
                this.flowDirection = 0;
                let randFlow = random();
                if (randFlow < 0.45) {
                    this.flowDirection = 1;
                } else if (randFlow < 0.90) {
                    this.flowDirection = -1;
                }
                this.flowingElements = [];
                this.flowSpawnRate = floor(random(30, 90));
                // Restored original flow element count
                this.maxFlowElements = floor(random(3, 8));
                this.flowElementBaseSize = random(0.5, 1.5);
            }

            applyForce(force) {
                this.acc.add(force);
            }

            update() {
                let noiseFactor = 0.001;
                let nx = map(noise(this.noiseOffset, frameCount * noiseFactor, 0), 0, 1, -this.maxForce, this.maxForce);
                let ny = map(noise(this.noiseOffset + 1000, frameCount * noiseFactor, 0), 0, 1, -this.maxForce, this.maxForce);
                let nz = map(noise(this.noiseOffset + 2000, frameCount * noiseFactor, 0), 0, 1, -this.maxForce, this.maxForce);
                this.applyForce(createVector(nx, ny, nz));

                let currentDistance = this.pos.mag();
                if (currentDistance > this.maxOrbitRadius) {
                    let steer = p5.Vector.sub(createVector(0,0,0), this.pos);
                    steer.setMag(map(currentDistance, this.maxOrbitRadius, this.maxOrbitRadius + 50, 0, this.maxForce * 0.7));
                    this.applyForce(steer);
                } else if (currentDistance < this.minOrbitRadius) {
                    let steer = p5.Vector.sub(this.pos, createVector(0,0,0));
                    steer.setMag(map(currentDistance, this.minOrbitRadius, this.minOrbitRadius - 50, 0, this.maxForce * 0.7));
                    this.applyForce(steer);
                }

                let tangentialForce = createVector(-this.pos.y, this.pos.x, this.pos.z * 0.1).normalize();
                tangentialForce.mult(this.maxForce * 0.2);
                this.applyForce(tangentialForce);

                this.vel.add(this.acc);
                this.vel.limit(this.maxSpeed);
                this.pos.add(this.vel);
                this.acc.mult(0);
                this.vel.mult(0.95);

                this.positionHistory.push(this.pos.copy());
                if (this.positionHistory.length > this.historyLength) {
                    this.positionHistory.shift();
                }

                if (this.flowDirection !== 0) {
                    if (frameCount % this.flowSpawnRate === 0 && this.flowingElements.length < this.maxFlowElements) {
                        this.flowingElements.push({
                            offset: this.flowDirection === 1 ? 0 : 1,
                            // MODIFICATION: Speed reduced by 50%
                            speed: random(0.00125, 0.00375),
                            size: random(0.625, 1.875) * this.flowElementBaseSize
                        });
                    }
                    for (let i = this.flowingElements.length - 1; i >= 0; i--) {
                        let flowEl = this.flowingElements[i];
                        flowEl.offset += flowEl.speed * this.flowDirection;
                        if ((this.flowDirection === 1 && flowEl.offset > 1.1) || (this.flowDirection === -1 && flowEl.offset < -0.1)) {
                            this.flowingElements.splice(i, 1);
                        }
                    }
                }
            }

            applyAudioInfluence(history) {
                let currentDistance = this.pos.mag();
                let distanceInfluenceFactor = map(currentDistance, this.minOrbitRadius, this.maxOrbitRadius, 1.0, 0.1, true);
                let delayFrames = floor(constrain(map(currentDistance, this.minOrbitRadius, this.maxOrbitRadius, 0, historyLength - 1), 0, historyLength - 1));
                let delayedAudio = history[(historyLength - 1) - delayFrames] || { volume: 0, bass: 0 };

                let effectiveAmplitude = (delayedAudio.volume > minActivationVolume) ? delayedAudio.volume : 0;
                let effectiveBass = (delayedAudio.bass > minActivationBass) ? delayedAudio.bass : 0;

                let volumeInfluenceAmount = map(effectiveAmplitude, minActivationVolume, 0.6, 0, 1, true);
                let bassInfluenceAmount = map(effectiveBass, minActivationBass, 200, 0, 1, true);
                let totalAudioInfluence = max(volumeInfluenceAmount, bassInfluenceAmount) * distanceInfluenceFactor;

                this.targetSize = (this.baseSize * 0.5) + (this.baseSize * 9.0 * totalAudioInfluence);
                let targetBrightness = (totalAudioInfluence > 0) ? 1.0 : 0.5;

                // Restored original lerp factors for responsiveness
                let lerpFactorBrightness = 0.1;
                if (targetBrightness < this.currentBrightnessFactor) {
                    lerpFactorBrightness = 0.3;
                }
                this.currentBrightnessFactor = lerp(this.currentBrightnessFactor, targetBrightness, lerpFactorBrightness);

                let lerpFactorSize;
                if (this.targetSize > this.size) {
                    lerpFactorSize = 0.1;
                } else {
                    lerpFactorSize = 0.3;
                }
                this.size = lerp(this.size, this.targetSize, lerpFactorSize);
            }

            display(graphicsBuffer) {
                if (this.flowDirection === 0) return;

                // Draw internal glows (restored original complexity)
                for (let i = 0; i < this.positionHistory.length; i++) {
                    let p = this.positionHistory[i];
                    let internalGlowAlpha = map(i, 0, this.historyLength, 0, this.currentBrightnessFactor * 200);
                    internalGlowAlpha = constrain(internalGlowAlpha, 0, 255);

                    graphicsBuffer.push();
                    graphicsBuffer.noStroke();
                    graphicsBuffer.fill(this.originalRGB[0], this.originalRGB[1], this.originalRGB[2], internalGlowAlpha);
                    graphicsBuffer.blendMode(ADD);
                    graphicsBuffer.sphere(map(i, 0, this.historyLength, this.size * 0.1, this.size * 0.6));
                    graphicsBuffer.pop();
                }

                graphicsBuffer.push();
                graphicsBuffer.stroke(this.originalRGB[0], this.originalRGB[1], this.originalRGB[2], this.currentBrightnessFactor * 100);
                graphicsBuffer.strokeWeight(map(this.currentBrightnessFactor, 0.5, 1.0, 0.5, 2.5));
                graphicsBuffer.line(this.pos.x, this.pos.y, this.pos.z, 0, 0, 0);
                graphicsBuffer.pop();

                if (this.flowDirection !== 0) {
                    graphicsBuffer.push();
                    graphicsBuffer.blendMode(ADD);
                    let centerPoint = createVector(0, 0, 0);
                    for (let flowEl of this.flowingElements) {
                        let pFlow = (this.flowDirection === 1) ?
                            p5.Vector.lerp(centerPoint, this.pos, flowEl.offset) :
                            p5.Vector.lerp(this.pos, centerPoint, 1 - flowEl.offset);

                        let flowProgressAlpha = (this.flowDirection === -1) ? 1 - flowEl.offset : flowEl.offset;
                        let flowAlpha = 255;
                        if (flowProgressAlpha < 0.1) flowAlpha = map(flowProgressAlpha, 0, 0.1, 100, 255);
                        else if (flowProgressAlpha > 0.9) flowAlpha = map(flowProgressAlpha, 0.9, 1, 255, 100);

                        flowAlpha = constrain(this.currentBrightnessFactor * flowAlpha, 0, 255);
                        
                        // MODIFICATION: Calculate size based on audio activity (proxied by brightness)
                        // When idle (brightness 0.5), multiplier is 0.5. When active (1.0), multiplier is 1.0.
                        let sizeMultiplier = map(this.currentBrightnessFactor, 0.5, 1.0, 0.5, 1.0, true);
                        let displaySize = flowEl.size * sizeMultiplier;

                        graphicsBuffer.noStroke();
                        graphicsBuffer.fill(this.originalRGB[0], this.originalRGB[1], this.originalRGB[2], flowAlpha);
                        graphicsBuffer.push();
                        graphicsBuffer.translate(pFlow.x, pFlow.y, pFlow.z);
                        graphicsBuffer.sphere(displaySize);
                        graphicsBuffer.pop();
                    }
                    graphicsBuffer.pop();
                }

                graphicsBuffer.push();
                graphicsBuffer.translate(this.pos.x, this.pos.y, this.pos.z);
                graphicsBuffer.noStroke();
                graphicsBuffer.push();
                graphicsBuffer.fill(this.originalRGB[0], this.originalRGB[1], this.originalRGB[2], this.currentBrightnessFactor * 150);
                graphicsBuffer.blendMode(ADD);
                graphicsBuffer.sphere(this.size * 1.8);
                graphicsBuffer.pop();
                graphicsBuffer.fill(this.originalRGB[0] * this.currentBrightnessFactor,
                                     this.originalRGB[1] * this.currentBrightnessFactor,
                                     this.originalRGB[2] * this.currentBrightnessFactor, 255);
                graphicsBuffer.sphere(this.size);
                graphicsBuffer.pop();
            }
        }

        class CentralClusterSphere {
            constructor() {
                let radius = map(pow(random(1), 2), 0, 1, 0, centralSphereSize * 0.8);
                this.pos = p5.Vector.random3D().mult(radius);
                this.baseSize = random(1, 3);
                this.size = this.baseSize;
                this.noiseOffset = random(1000);
                this.color = sphereColors[floor(random(sphereColors.length))];
                this.brightnessFactor = random(0.3, 0.7);
            }
            update() {
                let noiseFactor = 0.005;
                let nx = map(noise(this.noiseOffset, frameCount * noiseFactor, 0), 0, 1, -0.5, 0.5);
                let ny = map(noise(this.noiseOffset + 100, frameCount * noiseFactor, 0), 0, 1, -0.5, 0.5);
                let nz = map(noise(this.noiseOffset + 200, frameCount * noiseFactor, 0), 0, 1, -0.5, 0.5);
                this.pos.add(createVector(nx, ny, nz).mult(0.1));
                if (this.pos.mag() > centralSphereSize * 0.8) {
                    this.pos.setMag(centralSphereSize * 0.8);
                }
            }
            applyAudioInfluence(volume, bass) {
                let effectiveVolume = (volume > minActivationVolume) ? volume : 0;
                let effectiveBass = (bass > minActivationBass) ? bass : 0;
                let volumeInfluenceAmount = map(effectiveVolume, minActivationVolume, 0.6, 0, 1, true);
                let bassInfluenceAmount = map(effectiveBass, minActivationBass, 200, 0, 1, true);
                let totalAudioInfluence = max(volumeInfluenceAmount, bassInfluenceAmount);
                this.size = this.baseSize + (this.baseSize * 2 * totalAudioInfluence);
                this.brightnessFactor = lerp(this.brightnessFactor, 0.3 + (0.7 * totalAudioInfluence), 0.1);
            }
            display(graphicsBuffer) {
                graphicsBuffer.push();
                graphicsBuffer.translate(this.pos.x, this.pos.y, this.pos.z);
                graphicsBuffer.noStroke();
                graphicsBuffer.fill(this.color[0] * this.brightnessFactor,
                                     this.color[1] * this.brightnessFactor,
                                     this.color[2] * this.brightnessFactor,
                                     this.brightnessFactor * 255);
                graphicsBuffer.sphere(this.size);
                graphicsBuffer.pop();
            }
        }

        function setup() {
            createCanvas(windowWidth, windowHeight, WEBGL);
            pixelDensity(1);

            mainSceneBuffer = createGraphics(width, height, WEBGL);
            mainSceneBuffer.pixelDensity(1);

            for (let i = 0; i < numParticles; i++) {
                particles.push(new ParticleSphere());
            }
            for (let i = 0; i < numCentralClusterSpheres; i++) {
                centralClusterSpheres.push(new CentralClusterSphere());
            }

            startButton = document.getElementById('startButton');
            startButton.addEventListener('click', startAudio);

            targetSceneRotationX = sceneRotationX;
            targetSceneRotationY = sceneRotationY;
        }

        function mousePressed() {
            isDragging = true;
            prevMouseX = mouseX;
            prevMouseY = mouseY;
        }

        function mouseReleased() {
            isDragging = false;
        }

        function mouseDragged() {
            if (isDragging) {
                let dx = mouseX - prevMouseX;
                let dy = mouseY - prevMouseY;
                targetSceneRotationY += dx * 0.005;
                targetSceneRotationX -= dy * 0.005;
                prevMouseX = mouseX;
                prevMouseY = mouseY;
            }
        }

        function touchStarted(event) {
            if (event.target.tagName === 'CANVAS') {
                if (touches.length > 0) {
                    isDragging = true;
                    prevMouseX = touches[0].x;
                    prevMouseY = touches[0].y;
                }
                return false;
            }
        }

        function touchEnded(event) {
            isDragging = false;
            if (event.target.tagName === 'CANVAS') {
                return false;
            }
        }

        function touchMoved(event) {
            if (isDragging && touches.length > 0) {
                let dx = touches[0].x - prevMouseX;
                let dy = touches[0].y - prevMouseY;
                targetSceneRotationY += dx * 0.005;
                targetSceneRotationX -= dy * 0.005;
                prevMouseX = touches[0].x;
                prevMouseY = touches[0].y;
            }
            if (event.target.tagName === 'CANVAS') {
                return false;
            }
        }

        function startAudio() {
            if (audioStarted) return;
            if (getAudioContext().state === 'suspended') {
                getAudioContext().resume();
            }
            mic = new p5.AudioIn();
            fft = new p5.FFT(0.8, 128);
            fft.setInput(mic);
            mic.start(() => {
                audioStarted = true;
                startButton.disabled = true;
            }, (err) => {
                console.error("Microphone access error:", err);
                showMessageBox("Microphone access denied or not available. Please allow microphone access to enable voice reactivity.");
                audioStarted = true;
                startButton.disabled = true;
            });
        }

        function windowResized() {
            resizeCanvas(windowWidth, windowHeight);
            mainSceneBuffer = createGraphics(width, height, WEBGL);
            mainSceneBuffer.pixelDensity(1);
        }

        function draw() {
            // Render the entire scene to the off-screen buffer
            mainSceneBuffer.background(0, 0);
            mainSceneBuffer.push();

            sceneRotationX = lerp(sceneRotationX, targetSceneRotationX, rotationLerpFactor);
            sceneRotationY = lerp(sceneRotationY, targetSceneRotationY, rotationLerpFactor);
            mainSceneBuffer.rotateX(sceneRotationX);
            mainSceneBuffer.rotateY(sceneRotationY);
            let rotationSpeedFactor = 0.005;
            let noiseIncrement = 0.005;
            sceneRotationZ += map(noise(sceneNoiseOffsetZ), 0, 1, -rotationSpeedFactor, rotationSpeedFactor);
            sceneNoiseOffsetZ += noiseIncrement;
            mainSceneBuffer.rotateZ(sceneRotationZ);

            if (audioStarted) {
                if (mic && mic.enabled && getAudioContext().state === 'running') {
                    currentVolume = mic.getLevel();
                    fft.analyze();
                    bassEnergy = fft.getEnergy('bass');
                } else {
                    currentVolume = 0.0;
                    bassEnergy = 0;
                }
                audioHistory.push({ volume: currentVolume, bass: bassEnergy });
                if (audioHistory.length > historyLength) {
                    audioHistory.shift();
                }

                let effectiveVolumeCentral = (currentVolume > minActivationVolume) ? currentVolume : 0;
                let effectiveBassEnergyCentral = (bassEnergy > minActivationBass) ? bassEnergy : 0;
                let targetCentralSphereSize = 150;
                targetCentralSphereSize += map(effectiveVolumeCentral, minActivationVolume, 0.6, 0, 112.5, true);
                targetCentralSphereSize += map(effectiveBassEnergyCentral, minActivationBass, 200, 0, 45, true);

                for (let sphere of centralClusterSpheres) {
                    sphere.update();
                    sphere.applyAudioInfluence(currentVolume, bassEnergy);
                    sphere.display(mainSceneBuffer);
                }
                for (let particle of particles) {
                    particle.update();
                    particle.applyAudioInfluence(audioHistory);
                    particle.display(mainSceneBuffer);
                }

                mainSceneBuffer.push();
                mainSceneBuffer.noStroke();
                mainSceneBuffer.fill(0, 255);
                mainSceneBuffer.sphere(targetCentralSphereSize, centralSphereDetailX, centralSphereDetailY);
                mainSceneBuffer.pop();
            } else {
                while (audioHistory.length < historyLength) {
                    audioHistory.push({ volume: 0.0, bass: 0 });
                }
                while (audioHistory.length > historyLength) {
                    audioHistory.shift();
                }
                for (let sphere of centralClusterSpheres) {
                    sphere.update();
                    sphere.applyAudioInfluence(0, 0);
                    sphere.display(mainSceneBuffer);
                }
                for (let particle of particles) {
                    particle.update();
                    particle.applyAudioInfluence(audioHistory);
                    particle.display(mainSceneBuffer);
                }
                mainSceneBuffer.push();
                mainSceneBuffer.noStroke();
                mainSceneBuffer.fill(0, 255);
                mainSceneBuffer.sphere(centralSphereSize, centralSphereDetailX, centralSphereDetailY);
                mainSceneBuffer.pop();
            }
            mainSceneBuffer.pop();

            // Draw the buffer to the main canvas once.
            // This is much more performant than the multi-pass chromatic aberration effect.
            background(0);
            image(mainSceneBuffer, -width / 2, -height / 2);
        }
    </script>
</body>
</html>
